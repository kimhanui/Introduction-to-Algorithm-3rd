# Insertion Sorting pseudocode
- 의사코드

![삽입정렬-의사코드](https://user-images.githubusercontent.com/70448161/92952926-c0349080-f49b-11ea-9878-9413450057af.PNG)

- 정렬방식

![삽입정렬-그림](https://user-images.githubusercontent.com/70448161/92952941-c6c30800-f49b-11ea-80a0-fa4ad60881a8.PNG)

- 타당성 검사

##### 알고리즘의 타당성 검사는 루프 불변성을 이용해서 증명한다
----
**1. 초기조건**
>>먼저 루프의 첫 반복이 시작되기, 즉 j = 2일 때 루프 불변성이 성립하는 지를 확인한다. 이때 부분 배열 A[1 ... j-1]은 A[1] 한개의 원소로 구성되는데, 원래는 A[1]의 값이다. 게다가 그 부분 배열은 정렬되어 있으므로 루프의 첫 반복 시작 전에 루프 불변성이 성립한다

**2. 유지조건**
>> 다음으로 두 번째 특성, 즉 매 반복 시 루프 불변성이 유지되는지를 살펴본다. for 루프의 바디 부분은 A[j]의 올바른 위치를 찾을 때 까지 A[j-1] , A[j-2] , A[j-3] 오른쪽으로 한자리씩 이동시키는 작업을 한다.그러면 배열 A[1..j]는 기존 배열 A[1..j]와 동일한 원소를 정렬한 상태로 갖게 된다. j가 1씩 증가하면서 for루프의 다음 반복에서 루프 불변성이 유지된다.

**3. 종료조건**
>> 마지막으로 루프가 종료되었 을 때 어떤 상황이 발생하는지 조사해본다. 삽입 정렬의 경우 for 루프는 j가 A.length = n 보다 커질 때 , 즉 j가 1씩 증가 하므로 j=n+1일때 종료된다. 앞의 루프 불변성의 기술에서 j에 n+1을 넣어 보면 부분 배열 A[1...n]은 원래 A[1...n]의 원소로 구성되지만 정렬된 순서로 저장됨을 알 수 있다. 여기서 A[1...n]은 전체 배열이므로 배열 전체가 정렬 되었으며 이는 알고리즘이 타당함을 의미한다.
